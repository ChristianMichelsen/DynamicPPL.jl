---
title: Compiling with the `@model` Macro
---

Turing's "compiles" models by rewriting user-provided functions with the `@model` macro, creating a new function. This function returns a `Model` object when called on a dataset.

Let's take this example:
```julia
@model function gauss(x = missing, y = 1.0, ::Type{TV} = Vector{Float64}) where {TV<:AbstractVector}
    if x === missing
        x = TV(undef, 3)
    end
    p = TV(undef, 2)
    p[1] ~ InverseGamma(2, 3)
    p[2] ~ Normal(0, 1.0)
    @. x[1:2] ~ Normal(p[2], sqrt(p[1]))
    x[3] ~ Normal()
    y ~ Normal(p[2], sqrt(p[1]))
end
```

Turing compiles this in 3 steps.

## Step 1: Break up the model definition

First, the `@model` macro breaks up the user-provided function definition using `DynamicPPL.build_model_info`. This function
returns a dictionary consisting of:
- `allargs_exprs`: The expressions of the positional and keyword arguments, without default values.
- `allargs_syms`: The names of the positional and keyword arguments, e.g., `[:x, :y, :TV]` above.
- `allargs_namedtuple`: An expression that constructs a `NamedTuple` of the positional and keyword arguments, e.g., `:((x = x, y = y, TV = TV))` above.
- `defaults_namedtuple`: An expression that constructs a `NamedTuple` of the default positional and keyword arguments, if any, e.g., `:((x = missing, y = 1, TV = Vector{Float64}))` above.
- `modeldef`: A dictionary with the name, arguments, and function body of the model definition, as returned by `MacroTools.splitdef`.

## Step 2: Generate the body of the internal model function

In a second step, `DynamicPPL.generate_mainbody` generates the main part of the transformed function body using the user-provided function body
and the provided function arguments, without default values, for figuring out if a variable denotes an observation or a random variable.
Hereby the function `DynamicPPL.generate_tilde` replaces the `L ~ R` lines in the model and the function `DynamicPPL.generate_dot_tilde` replaces
the `@. L ~ R` and `L .~ R` lines in the model.

In the above example, `p[1] ~ InverseGamma(2, 3)` is replaced with something similar to
```julia
#= REPL[25]:6 =#
begin
    var"##tmpright#323" = InverseGamma(2, 3)
    var"##tmpright#323" isa Union{Distribution, AbstractVector{<:Distribution}} || throw(ArgumentError("Right-hand side of a ~ must be subtype of Distribution or a vector of Distributions."))
    var"##vn#325" = (DynamicPPL.VarName)(:p, ((1,),))
    var"##inds#326" = ((1,),)
    p[1] = (DynamicPPL.tilde_assume)(_rng, _context, _sampler, var"##tmpright#323", var"##vn#325", var"##inds#326", _varinfo)
end
```
Here the first line is a so-called line number node that enables more helpful error messages by providing users with the exact location
of the error in their model definition. Then the right hand side (RHS) of the `~` is assigned to a variable (with an automatically generated name).
We check that the RHS is a distribution or an array of distributions, otherwise an error is thrown.
Next we extract a compact representation of the variable with its name and index (or indices). Finally, the `~` expression is replaced with
a call to `DynamicPPL.tilde_assume` since the compiler figured out that `p[1]` is a random variable using the following
heuristic:
1. If the symbol on the LHS of `~`, `:p` in this case, is not among the arguments to the model, `(:x, :y, :T)` in this case, it is a random variable. 
2. If the symbol on the LHS of `~`, `:p` in this case, is among the arguments to the model but has a value of `missing`, it is a random variable.
2. If the value of the LHS of `~`, `p[1]` in this case, is `missing`, then it is a random variable.
4. Otherwise, it is treated as an observation.

The `DynamicPPL.tilde_assume` function takes care of sampling the random variable, if needed, and updating its value and the accumulated log joint
probability in the `_varinfo` object. If `L ~ R` is an observation, `DynamicPPL.tilde_observe` is called with the same arguments except the
random number generator `_rng` (since observations are never sampled).

A similar transformation is performed for expressions of the form `@. L ~ R` and `L .~ R`. For instance,
`@. x[1:2] ~ Normal(p[2], sqrt(p[1]))` is replaced with
```julia
#= REPL[25]:8 =#
begin
    var"##tmpright#331" = Normal.(p[2], sqrt.(p[1]))
    var"##tmpright#331" isa Union{Distribution, AbstractVector{<:Distribution}} || throw(ArgumentError("Right-hand side of a ~ must be subtype of Distribution or a vector of Distributions."))
    var"##vn#333" = (DynamicPPL.VarName)(:x, ((1:2,),))
    var"##inds#334" = ((1:2,),)
    var"##isassumption#335" = begin
        let var"##vn#336" = (DynamicPPL.VarName)(:x, ((1:2,),))
            if !((DynamicPPL.inargnames)(var"##vn#336", _model)) || (DynamicPPL.inmissings)(var"##vn#336", _model)
                true
            else
                x[1:2] === missing
            end
        end
    end
    if var"##isassumption#335"
        x[1:2] .= (DynamicPPL.dot_tilde_assume)(_rng, _context, _sampler, var"##tmpright#331", x[1:2], var"##vn#333", var"##inds#334", _varinfo)
    else
        (DynamicPPL.dot_tilde_observe)(_context, _sampler, var"##tmpright#331", x[1:2], var"##vn#333", var"##inds#334", _varinfo)
    end
end
```
The main difference in the expanded code between `L ~ R` and `@. L ~ R` is that the former doesn't assume `L` to be defined, it can be a new Julia variable in the scope, while the latter assumes `L` already exists. Moreover, `DynamicPPL.dot_tilde_assume` and `DynamicPPL.dot_tilde_observe` are called
instead of `DynamicPPL.tilde_assume` and `DynamicPPL.tilde_observe`.

## Step 3: Replace the user-provided function body

Finally, we replace the user-provided function body using `DynamicPPL.build_output`. This function uses `MacroTools.combinedef` to reassemble
the user-provided function with a new function body. In the modified function body an anonymous function is created whose function body
was generated in step 2 above and whose arguments are
- a random number generator `_rng`,
- a model `_model`,
- a datastructure `_varinfo`,
- a sampler `_sampler`,
- a sampling context `_context`,
- and all positional and keyword arguments of the user-provided model function as positional arguments
without any default values. Finally, in the new function body a `model::Model` with this anonymous function as internal function is returned.
